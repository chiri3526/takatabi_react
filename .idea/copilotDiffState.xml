<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/pages/ArticlePage.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/pages/ArticlePage.js" />
              <option name="originalContent" value="import React, { useEffect, useRef, useMemo } from 'react';&#10;import { Link } from 'react-router-dom';&#10;import styled from '@emotion/styled';&#10;import { theme } from '../styles/theme';&#10;import { FaLink, FaArrowLeft } from 'react-icons/fa';&#10;import { fetchArticleById, fetchArticles } from '../api/microcms';&#10;&#10;// JSONファイルを一括取得（記事一覧を作るため）&#10;function importAllJson(r) {&#10;  return r.keys().map(key =&gt; {&#10;    const data = r(key);&#10;    return {&#10;      id: data.id || data.slug || key.replace(/^.*[/]/, '').replace(/\.json$/, ''),&#10;      ...data&#10;    };&#10;  });&#10;}&#10;&#10;const jsonArticles = importAllJson(require.context('../articles', false, /\.json$/));&#10;&#10;// blogPosts: HomePage/CategoryPageと同じローカル記事配列を定義&#10;const blogPosts = [&#10;  ...jsonArticles&#10;  // 必要ならここにjs記事やテスト記事を追加可能&#10;];&#10;&#10;&#10;// Google AdSense script を head に挿入するユーティリティ（重複挿入を防止）&#10;function useAdsenseScript() {&#10;  // 実行環境でのみ DOM にスクリプトを挿入&#10;  try {&#10;    if (typeof document === 'undefined') return;&#10;    if (!document.querySelector('script[src*=&quot;adsbygoogle.js?client=ca-pub-7728107798566122&quot;]')) {&#10;      const script = document.createElement('script');&#10;      script.async = true;&#10;      script.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7728107798566122';&#10;      script.crossOrigin = 'anonymous';&#10;      document.head.appendChild(script);&#10;    }&#10;  } catch (e) {&#10;    // サーバーサイド環境やテスト環境では無視&#10;  }&#10;}&#10;&#10;// 目次生成関数&#10;function generateTocAndContent(html) {&#10;  if (!html) return { toc: [], html };&#10;  let idx = 0;&#10;  const toc = [];&#10;  // h2/h3タグにidを付与しつつtoc配列を作る&#10;  let newHtml = html.replace(/&lt;(h[23])([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g, (match, tag, attrs, text) =&gt; {&#10;    const cleanText = text.replace(/&lt;[^&gt;]+&gt;/g, '');&#10;    const id = `heading-${tag}-${idx++}`;&#10;    toc.push({ tag, text: cleanText, id });&#10;    return `&lt;${tag} id=&quot;${id}&quot;${attrs}&gt;${text}&lt;/${tag}&gt;`;&#10;  });&#10;  // imgタグのsrcが/contents/で始まる場合、絶対パスに補正&#10;  newHtml = newHtml.replace(/&lt;img([^&gt;]*?)src=[&quot;'](\/contents\/[^&quot;'&gt;]+)[&quot;']([^&gt;]*)&gt;/g, (match, before, src, after) =&gt; {&#10;    return `&lt;img${before}src=&quot;${src}&quot;${after}&gt;`;&#10;  });&#10;&#10;  // --- 追加: img の inline 属性(width/height/style) を削除し class=&quot;cms-image&quot; を付与 ---&#10;  newHtml = newHtml.replace(/&lt;img([^&gt;]*)&gt;/g, (match, attrs) =&gt; {&#10;    // attrs 部から width, height, style を削除&#10;    let cleaned = attrs.replace(/\s*(width|height)=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    cleaned = cleaned.replace(/\s*style=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    // class があれば追記、なければ追加&#10;    if (/class=/.test(cleaned)) {&#10;      cleaned = cleaned.replace(/class=(&quot;|')(.*?)(&quot;|')/i, (m, q, cls) =&gt; `class=${q}${cls} cms-image${q}`);&#10;    } else {&#10;      cleaned = `${cleaned} class=&quot;cms-image&quot;`;&#10;    }&#10;    return `&lt;img${cleaned}&gt;`;&#10;  });&#10;&#10;  // --- 追加: Google Maps のリンクを短いラベルに置換して target/rel を付与 ---&#10;  newHtml = newHtml.replace(/&lt;a([^&gt;]*href=[&quot;'][^&quot;']*google\.com\/maps[^&quot;']*[&quot;'][^&gt;]*)&gt;(.*?)&lt;\/a&gt;/gi, (match, attrs, inner) =&gt; {&#10;    let cleaned = attrs.replace(/\s*target=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    cleaned = cleaned.replace(/\s*rel=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    return `&lt;a${cleaned} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt; Googleマップ&lt;/a&gt;`;&#10;  });&#10;&#10;  // --- 追加: ブラウザ環境では DOMParser を使って外部リンクをカードに変換 ---&#10;  try {&#10;    if (typeof window !== 'undefined' &amp;&amp; typeof window.DOMParser !== 'undefined') {&#10;      const parser = new DOMParser();&#10;      const doc = parser.parseFromString(newHtml, 'text/html');&#10;      const anchors = Array.from(doc.querySelectorAll('a'));&#10;      anchors.forEach(a =&gt; {&#10;        try {&#10;          const href = a.getAttribute('href');&#10;          if (!href) return;&#10;          const url = new URL(href, window.location.origin);&#10;          const isHttp = /^https?:/.test(url.protocol);&#10;          const isSameOrigin = url.origin === window.location.origin;&#10;          if (isHttp &amp;&amp; !isSameOrigin) {&#10;            const domain = url.hostname.replace(/^www\./, '');&#10;            // 既に同じ href の external-link が container 内にあれば重複作成をスキップ&#10;              try {&#10;                const existing = doc.querySelector(`a.external-link[href=&quot;${href}&quot;]`);&#10;                if (existing) {&#10;                  if (a.dataset) a.dataset.previewApplied = '1';&#10;                  return;&#10;                }&#10;              } catch (e) { }&#10;&#10;&#10;            // ext-inner を作って内部を構築&#10;            const wrapper = doc.createElement('div');&#10;            wrapper.className = 'ext-inner';&#10;&#10;            // ファビコンは表示しない（省略）: meta のみ作成&#10;            const meta = doc.createElement('div');&#10;            meta.className = 'ext-meta';&#10;&#10;            const titleDiv = doc.createElement('div');&#10;            titleDiv.className = 'ext-title';&#10;            titleDiv.textContent = a.textContent ? a.textContent.trim() : href;&#10;&#10;            const domainDiv = doc.createElement('div');&#10;            domainDiv.className = 'ext-domain';&#10;            domainDiv.textContent = domain;&#10;&#10;            meta.appendChild(titleDiv);&#10;            meta.appendChild(domainDiv);&#10;&#10;            // wrapper の順序: メタのみ（ファビコンなし）&#10;            wrapper.appendChild(meta);&#10;&#10;            // 追加: 外部感を示す小さな矢印アイコンを追加&#10;            const arrow = doc.createElement('span');&#10;            arrow.className = 'ext-arrow';&#10;            arrow.innerHTML = `&#10;              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; aria-hidden=&quot;true&quot;&gt;&#10;                &lt;path d=&quot;M5 12h14&quot;&gt;&lt;/path&gt;&#10;                &lt;path d=&quot;M12 5l7 7-7 7&quot;&gt;&lt;/path&gt;&#10;              &lt;/svg&gt;`;&#10;            wrapper.appendChild(arrow);&#10;&#10;            // アンカー自体を外部リンク表示に調整&#10;            a.innerHTML = '';&#10;            a.appendChild(wrapper);&#10;            // preserve existing classes and add external-link&#10;            a.className = (a.className ? a.className + ' external-link' : 'external-link');&#10;            a.setAttribute('target', '_blank');&#10;            a.setAttribute('rel', 'noopener noreferrer');&#10;            // 変換済みフラグを付与（クライアント側処理の重複を避けるため）&#10;            a.setAttribute('data-preview-applied', '1');&#10;          }&#10;        } catch (e) {&#10;          // 個別アンカーの変換エラーは無視&#10;        }&#10;      });&#10;      // --- 追加: サーバ側で同一 href の external-link を重複削除 ---&#10;      try {&#10;        const seen = new Set();&#10;        const anchorsAll = Array.from(doc.querySelectorAll('a.external-link'));&#10;        anchorsAll.forEach(el =&gt; {&#10;          try {&#10;            const href0 = el.getAttribute('href');&#10;            if (!href0) return;&#10;            if (seen.has(href0)) {&#10;              el.parentNode &amp;&amp; el.parentNode.removeChild(el);&#10;            } else {&#10;              seen.add(href0);&#10;            }&#10;          } catch (e) {}&#10;        });&#10;      } catch (e) {}&#10;&#10;      // シリアライズして戻す&#10;      newHtml = doc.body.innerHTML;// シリアライズして戻す&#10;      newHtml = doc.body.innerHTML;&#10;    }&#10;  } catch (e) {&#10;    // DOMParser 系のエラーは無視して元の newHtml を返す&#10;  }&#10;&#10;  return { toc, html: newHtml };&#10;}&#10;&#10;const TocList = styled.ul`&#10;  list-style: none;&#10;  margin: 0;&#10;  padding: 0;&#10;`;&#10;const TocItem = styled.li`&#10;  margin: 0.2em 0 0.2em 0.5em;&#10;  &amp;.toc-h3 { margin-left: 1.5em; font-size: 0.95em; }&#10;`;&#10;const TocLink = styled.a`&#10;  color: #2E7D32;&#10;  text-decoration: none;&#10;  &amp;:hover { text-decoration: underline; color: #1B5E20; }&#10;`;&#10;&#10;&#10;// 目次(Toc)コンポーネント&#10;const TocContainer = styled.nav`&#10;  background: #f6fff6;&#10;  border: 2px solid #2E7D32;&#10;  border-radius: 12px;&#10;  padding: 1em 1.5em;&#10;  margin: 2em auto 2em auto;&#10;  font-size: 0.98rem;&#10;  width: 60%;&#10;  max-width: 500px;&#10;  min-width: 220px;&#10;  box-sizing: border-box;&#10;  display: block;&#10;  @media (max-width: 600px) {&#10;    width: 80vw;&#10;    font-size: 0.92rem;&#10;    padding: 0.7em 0.7em;&#10;  }&#10;`;&#10;const ArticleContent = styled.div`&#10;  /* CONSOLIDATED: external-link unified card */&#10;&#10;  /* Support standalone .ext-inner (server-produced) to display as unified card) */&#10;  .ext-inner {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.9rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    position: relative;&#10;    overflow: hidden;&#10;  }&#10;  /* Hide fully empty external-link anchors (e.g. stray anchors) */&#10;  a.external-link:empty { display: none; }&#10;  /* If an arrow anchor is a sibling after .ext-inner, visually overlap it on the card's right */&#10;  .ext-inner + a.external-link {&#10;    display: inline-flex;&#10;    align-items: center;&#10;    justify-content: center;&#10;    width: 40px;&#10;    margin-left: -40px; /* overlap into card */&#10;    padding: 0;&#10;    background: transparent;&#10;    border: none;&#10;  }&#10;  .ext-inner + a.external-link .ext-arrow {&#10;    position: relative;&#10;    right: 0;&#10;    top: 0;&#10;    transform: none;&#10;    width: 16px;&#10;    height: 16px;&#10;    display: block;&#10;    color: #2E7D32;&#10;  }&#10;&#10;  .external-link {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.9rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    text-decoration: none;&#10;    color: inherit;&#10;    transition: transform 0.12s ease, box-shadow 0.12s ease;&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    overflow: hidden;&#10;    position: relative;&#10;  }&#10;  .external-link:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,128,64,0.08); }&#10;  .external-link .ext-inner { display:flex; flex-direction:row; align-items:center; gap:0.8rem; width:100%; min-width:0; flex:1 1 auto; padding-right:40px; }&#10;  .external-link .ext-meta { display:flex; flex-direction:column; min-width:0; flex:1 1 auto; overflow:hidden; }&#10;  .external-link .ext-title { font-weight:700; color: #2E7D32; font-size:0.95rem; line-height:1.25; white-space:normal; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; }&#10;  .external-link .ext-domain { font-size:0.78rem; color: #21212188; margin-top:0.18rem; white-space:normal; word-break:break-all; }&#10;  .external-link .ext-arrow { position:absolute; right:12px; top:50%; transform:translateY(-50%); width:16px; height:16px; display:flex; align-items:center; justify-content:center; color:#2E7D32; pointer-events:none; }&#10;  .external-link .ext-arrow svg { width:100%; height:100%; display:block; stroke:currentColor; vector-effect:non-scaling-stroke; }&#10;  @media (max-width:600px) { .external-link{padding:0.36rem 0.6rem;} .external-link .ext-inner{gap:0.6rem; padding-right:36px;} .external-link .ext-title{font-size:0.92rem; -webkit-line-clamp:2;} .external-link .ext-domain{font-size:0.75rem;} .external-link .ext-arrow{right:10px; width:14px; height:14px;} }&#10;&#10;&#10;  color: ${theme.colors.text};&#10;  font-size: 1.0rem; /* 基本フォントを小さめに調整 */&#10;  line-height: 1.7;&#10;  font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;&#10;  /* 本文内リンクの折り返しと最大幅制御 */&#10;  a {&#10;    overflow-wrap: anywhere;&#10;    word-break: break-word;&#10;    display: inline-block;&#10;    max-width: 100%;&#10;  }&#10;&#10;  /* リンクプレビュー用スタイル */&#10;  .link-preview {&#10;    display: flex;&#10;    gap: 0.8em;&#10;    align-items: center;&#10;    border: 1px solid #e6f4ea;&#10;    background: transparent;&#10;    padding: 0.4rem;&#10;    border-radius: 8px;&#10;    margin-top: 0.6rem;&#10;    text-decoration: none;&#10;    color: inherit;&#10;  }&#10;  .link-preview img {&#10;    width: 84px;&#10;    height: 56px;&#10;    object-fit: cover;&#10;    border-radius: 6px;&#10;    flex-shrink: 0;&#10;    background: transparent;&#10;  }&#10;  .link-preview .lp-title {&#10;    font-weight: 700;&#10;    color: ${theme.colors.primary};&#10;    font-size: 0.92rem;&#10;    line-height: 1.2;&#10;  }&#10;&#10;  /* 追加: 外部リンク用のカード表示 */&#10;  .external-link_obsolete {&#10;    display: block; /* anchor をブロックにして横幅いっぱいのカードにする */&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.6rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    text-decoration: none;&#10;    color: inherit;&#10;    transition: transform 0.12s ease, box-shadow 0.12s ease;&#10;    width: 100%;&#10;    box-sizing: border-box; /* はみ出し防止 */&#10;    overflow: hidden;&#10;  }&#10;  .external-link_obsolete:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,128,64,0.08); }&#10;&#10;  /* 内部コンテナを横並びにする（左: favicon、右: meta） */&#10;  .external-link_obsolete .ext-inner{&#10;    display: flex;&#10;    flex-direction: row;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    width: 100%;&#10;    padding-right: 28px; /* 右端の矢印分の余白を確保（ファビコン無しで少し小さめ） */&#10;  }&#10;  .external-link_obsolete .ext-meta { display: flex; flex-direction: column; min-width: 0; flex: 1 1 auto; }&#10;  .external-link_obsolete .ext-title { font-weight: 700; color: ${theme.colors.primary}; font-size: 0.95rem; white-space: normal; overflow: visible; word-break: break-word; }&#10;  .external-link_obsolete .ext-domain { font-size: 0.75rem; color: ${theme.colors.text}99; margin-top: 0.18rem; white-space: normal; color: ${theme.colors.text}88; }&#10;&#10;  /* モバイル（小さい画面）での折返し対応 */&#10;  @media (max-width: 600px) {&#10;    .external-link_obsolete {&#10;      padding: 0.36rem 0.5rem;&#10;      gap: 0.6rem;&#10;      align-items: flex-start;&#10;      /* ext-inner が折り返す */&#10;    }&#10;    .external-link_obsolete .ext-favicon {&#10;      width: 28px !important;&#10;      height: 28px !important;&#10;    }&#10;    .external-link_obsolete .ext-meta { min-width: 0; }&#10;    .external-link_obsolete .ext-title {&#10;      white-space: normal; /* 折り返す */&#10;      font-size: 0.92rem;&#10;      line-height: 1.2;&#10;      overflow: visible;&#10;    }&#10;    .external-link_obsolete .ext-domain {&#10;      white-space: normal;&#10;      word-break: break-all; /* ドメインが長い場合に折り返す */&#10;      color: ${theme.colors.text}88;&#10;    }&#10;  }&#10;&#10;  /* 既存スタイル続行 */&#10;  h2 {&#10;    color: ${theme.colors.primary};&#10;    font-size: 1.3rem;&#10;    border-left: 7px solid ${theme.colors.primary};&#10;    border-radius: 0 12px 12px 0;&#10;    padding-left: 0.7em;&#10;    margin: 2em 0 1em 0;&#10;    font-weight: bold;&#10;    background: #f6fff6;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  h3 {&#10;    color: ${theme.colors.secondary};&#10;    font-size: 1.1rem;&#10;    margin: 1.5em 0 0.7em 0;&#10;    font-weight: bold;&#10;    border-left: 5px solid ${theme.colors.secondary};&#10;    border-radius: 0 10px 10px 0;&#10;    padding-left: 0.6em;&#10;    background: #eaffea;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  h4 {&#10;    color: ${theme.colors.accent};&#10;    font-size: 1.05rem;&#10;    margin: 1.2em 0 0.5em 0;&#10;    font-weight: bold;&#10;    border-left: 4px dashed ${theme.colors.accent};&#10;    border-radius: 0 8px 8px 0;&#10;    padding-left: 0.5em;&#10;    background: #f9fff6;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  strong, .em {&#10;    color: ${theme.colors.highlight};&#10;    background: #fffbe6;&#10;    font-weight: bold;&#10;    padding: 0 0.2em;&#10;    border-radius: 4px;&#10;  }&#10;&#10;  /* 本文内画像をコンテナ内に収める */&#10;  img.cms-image,&#10;  .cms-image {&#10;    border-radius: 16px;&#10;    width: 100% !important;&#10;    max-width: 920px !important;&#10;    height: auto !important;&#10;    object-fit: contain;&#10;    box-shadow: 0 2px 8px rgba(0,0,0,0.07);&#10;    margin: 1.6em auto;&#10;    display: block;&#10;    background: transparent;&#10;    padding: 0;&#10;  }&#10;&#10;  /* 横長カードを確実にするための微調整 */&#10;  .external-link_obsolete {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    width: 100%;&#10;    position: relative; /* 矢印を絶対配置で右端中央にするため */&#10;  }&#10;&#10;  /* タブレットで少し控えめに */&#10;  @media (max-width: 900px) {&#10;    /* モバイル/タブレットで画像がはみ出さないように調整 */&#10;    img,&#10;    .cms-image {&#10;      width: 100% !important;&#10;      max-width: 100% !important;&#10;      box-sizing: border-box;&#10;      margin: 1.4em 0;&#10;      padding: 0;&#10;    }&#10;  }&#10;&#10;  /* モバイルでは画像を少しはみ出させて目立たせつつ中央寄せ */&#10;  @media (max-width: 600px) {&#10;    font-size: 1.02rem; /* モバイルでも少し小さめに */&#10;    img.cms-image,&#10;    img:not(.ext-favicon) {&#10;      /* 安全に幅を100%にしてはみ出しを防止 */&#10;      width: 100% !important;&#10;      max-width: 100% !important;&#10;      margin: 1.2em 0;&#10;      transform: none;&#10;      border-radius: 12px;&#10;      display: block;&#10;      box-sizing: border-box;&#10;      padding: 0;&#10;    }&#10;  }&#10;&#10;  /* 見出しが長い単語やURLで幅を超えないように折返しを強制 */&#10;  h2, h3, h4 {&#10;    white-space: normal;&#10;    word-break: break-word;&#10;    overflow-wrap: anywhere;&#10;  }&#10;&#10;  /* 追加: 外部リンクカードに矢印アイコンを表示 */&#10;  .external-link_obsolete .ext-arrow {&#10;    position: absolute;&#10;    right: 12px;&#10;    top: 50%;&#10;    transform: translateY(-50%);&#10;    width: 16px;&#10;    height: 16px;&#10;    display: flex;&#10;    align-items: center;&#10;    justify-content: center;&#10;    color: ${theme.colors.primary};&#10;    pointer-events: none; /* アイコン自体はクリック対象にしない（アンカー全体がリンク） */&#10;  }&#10;  .external-link_obsolete .ext-arrow svg {&#10;    width: 100%;&#10;    height: 100%;&#10;    display: block;&#10;    stroke: currentColor;&#10;    vector-effect: non-scaling-stroke;&#10;  }&#10;  /* モバイル用: 矢印アイコンを小さく */&#10;  @media (max-width: 600px) {&#10;    .external-link_obsolete .ext-arrow {&#10;      right: 10px;&#10;      width: 14px;&#10;      height: 14px;&#10;    }&#10;  }&#10;&#10;  /* ここから表示幅を広げる調整 */&#10;  /* 元は width: 60%; max-width: 500px; min-width: 220px; */&#10;  width: 85%;&#10;  max-width: 1100px;&#10;  min-width: 300px;&#10;  margin-left: auto;&#10;  margin-right: auto;&#10;  box-sizing: border-box;&#10;&#10;  @media (max-width: 1000px) {&#10;    width: 92%;&#10;    max-width: 920px;&#10;    font-size: 0.98rem;&#10;    padding: 0.8em 0.8em;&#10;  }&#10;  @media (max-width: 600px) {&#10;    /* コンテナ内での100%幅にして親のパディングに合わせる（vw を使うと親の余白と衝突してはみ出す） */&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    font-size: 0.92rem;&#10;    padding: 0.7em 0.7em;&#10;  }&#10;`;&#10;&#10;const ArticleContainer = styled.div`&#10;  width: 70vw;&#10;  max-width: 1100px;&#10;  min-width: 320px;&#10;  margin: 40px auto;&#10;  background: transparent;&#10;  border-radius: 8px;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.08);&#10;  padding: ${theme.spacing.xlarge};&#10;  @media (max-width: 900px) {&#10;    width: 90vw;&#10;    max-width: 98vw;&#10;    padding: ${theme.spacing.large};&#10;  }&#10;`;&#10;const ArticleTitle = styled.h1`&#10;  font-size: 1.2rem; // 小さめに変更&#10;  color: ${theme.colors.primary};&#10;  margin-bottom: ${theme.spacing.medium};&#10;`;&#10;const ArticleImageEyeCatch = styled.img`&#10;  width: 100%;&#10;  aspect-ratio: 4 / 3;&#10;  object-fit: cover;&#10;  border-radius: 18px;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.13);&#10;  background: transparent;&#10;  margin-bottom: 1.5em;&#10;`;&#10;// 小さく表示する日付コンポーネント（アイキャッチ上に右寄せでオーバーレイ表示）&#10;const ArticleDate = styled.div`&#10;  font-size: 0.65rem; /* かなり小さく */&#10;  color: #444;&#10;  text-align: right;&#10;  position: absolute;&#10;  top: 8px; /* アイキャッチ右上に配置 */&#10;  right: 10px;&#10;  background: rgba(255,255,255,0.85);&#10;  padding: 0.12rem 0.4rem;&#10;  border-radius: 8px;&#10;  box-shadow: 0 1px 4px rgba(0,0,0,0.06);&#10;  z-index: 6;&#10;`;&#10;&#10;// 追加: アイキャッチ上に表示するタグのコンテナとバッジ&#10;// （記事ページではタグ表示不要のため削除）&#10;&#10;const BackLink = styled(Link)`&#10;  display: inline-flex;&#10;  align-items: center;&#10;  gap: 0.5em;&#10;  margin-top: ${theme.spacing.large};&#10;  color: ${theme.colors.primary};&#10;  text-decoration: none;&#10;  font-weight: bold;&#10;  font-size: 1.05rem;&#10;  background: #f6fff6;&#10;  border-radius: 6px;&#10;  padding: 0.5em 1.2em;&#10;  box-shadow: 0 2px 8px rgba(0,128,64,0.07);&#10;  border: 1.5px solid ${theme.colors.primary}33;&#10;  transition: background 0.2s, color 0.2s, border 0.2s;&#10;  &amp;:hover {&#10;    background: ${theme.colors.primary};&#10;    color: #fff;&#10;    border-color: ${theme.colors.primary};&#10;  }&#10;`;&#10;&#10;// 関連記事リスト&#10;const RelatedSection = styled.div`&#10;  margin-top: 48px;&#10;  text-align: center;&#10;`;&#10;const RelatedTitle = styled.h3`&#10;  color: ${theme.colors.primary};&#10;  font-size: 1.3rem;&#10;  font-weight: bold;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  gap: 0.5em;&#10;  margin-bottom: 1.5em;&#10;`;&#10;const RelatedList = styled.div`&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  justify-content: center;&#10;  gap: 2em;&#10;`;&#10;const RelatedCard = styled(Link)`&#10;  display: flex;&#10;  flex-direction: row;&#10;  align-items: center;&#10;  width: 640px; /* 横幅を広げる */&#10;  max-width: calc(100% - 40px);&#10;  min-height: 130px; /* 縦に少し広げる */&#10;  background: #f6fff6;&#10;  border-radius: 12px;&#10;  box-shadow: 0 3px 12px rgba(0,0,0,0.08);&#10;  text-decoration: none;&#10;  transition: box-shadow 0.2s, transform 0.12s;&#10;  border: 2px solid ${theme.colors.primary}22;&#10;  padding: 0.9em;&#10;  gap: 1em;&#10;  &amp;:hover {&#10;    transform: translateY(-4px);&#10;    box-shadow: 0 8px 28px rgba(0,128,64,0.14);&#10;    border-color: ${theme.colors.primary};&#10;  }&#10;  @media (max-width: 900px) {&#10;    width: calc(100% - 48px);&#10;  }&#10;  @media (max-width: 600px) {&#10;    width: calc(100% - 32px);&#10;    padding: 0.6em;&#10;    min-height: 110px;&#10;  }&#10;`;&#10;const RelatedImage = styled.img`&#10;  width: 44%; /* 画像幅を大きくして目立たせる */&#10;  aspect-ratio: 4 / 3;&#10;  object-fit: cover;&#10;  border-radius: 12px;&#10;  margin: 0;&#10;  flex-shrink: 0;&#10;`;&#10;const RelatedCardTitle = styled.div`&#10;  color: ${theme.colors.primary};&#10;  font-weight: 700;&#10;  font-size: 0.8rem;&#10;  text-align: left;&#10;  margin: 0;&#10;  line-height: 1.25;&#10;  word-break: break-word; /* 長い単語を折り返す */&#10;  white-space: normal; /* 折り返し許可 */&#10;`;&#10;&#10;const ArticlePage = (props) =&gt; {&#10;  useAdsenseScript();&#10;  const adRef = useRef(null);&#10;  const id = props.id;&#10;  // undefined = 未取得（loading）、object = 取得済、 null = 取得失敗（見つからない）&#10;&#10;  const [cmsArticle, setCmsArticle] = React.useState(undefined);&#10;  // microCMS の記事リスト（関連記事抽出用）&#10;  const [cmsArticlesList, setCmsArticlesList] = React.useState([]);&#10;  // アイキャッチ画像の縦横判定フックは必ず呼ぶ&#10;  const [isVertical, setIsVertical] = React.useState(false);&#10;  // postはuseMemoで取得されるため、imageUrlは毎回計算&#10;  const post = useMemo(() =&gt; {&#10;    // まずローカル記事を探す&#10;    const local = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;    if (local) return local;&#10;    // ローカルに無ければ microCMS記事（APIで取得結果）を返す&#10;    return cmsArticle;&#10;  }, [id, cmsArticle]);&#10;  const imageUrl = post?.image?.url || post?.image;&#10;&#10;  // ref: 本文コンテナを直接操作してリンクプレビュー挿入&#10;  const articleContentRef = useRef(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    // フックは必ず呼ばれる（条件分岐なし）&#10;    if (!imageUrl) {&#10;      setIsVertical(false);&#10;      return;&#10;    }&#10;    const img = new window.Image();&#10;    img.src = imageUrl;&#10;    img.onload = function() {&#10;      if (img.naturalHeight &gt; img.naturalWidth * 1.15) {&#10;        setIsVertical(true);&#10;      } else {&#10;        setIsVertical(false);&#10;      }&#10;    };&#10;  }, [imageUrl]);&#10;&#10;  // --- 追加: 記事の公開日 / 作成日 を安全に拾って日本ロケールで整形 ---&#10;  const publishedRaw = post?.publishedAt || post?.createdAt || post?.date || post?.published;&#10;  const publishedDate = publishedRaw&#10;    ? new Date(publishedRaw).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })&#10;    : null;&#10;&#10;  // 目次とid付きHTML生成（useEffectより前に定義しておく）&#10;  const { toc, html: contentWithIds } = useMemo(() =&gt; generateTocAndContent(post?.content), [post]);&#10;&#10;  useEffect(() =&gt; {&#10;    window.scrollTo(0, 0);&#10;    // ローカル記事がなければmicroCMS APIで取得（未取得フラグをセット）&#10;    const local = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;    if (!local) {&#10;      setCmsArticle(undefined); // loading&#10;      fetchArticleById(id).then(data =&gt; setCmsArticle(data)).catch(() =&gt; setCmsArticle(null));&#10;    } else {&#10;      // ローカル記事がある場合は CMS 側の状態をクリア&#10;      setCmsArticle(null);&#10;    }&#10;    // 関連記事抽出のため microCMS の一覧を取得（軽量）&#10;    fetchArticles().then(data =&gt; {&#10;      if (data &amp;&amp; Array.isArray(data.contents)) {&#10;        setCmsArticlesList(data.contents);&#10;      }&#10;    }).catch(() =&gt; {});&#10;  }, [id]);&#10;&#10;  // 記事本文の HTML に含まれるリンクを検出し、同一サイト内の記事リンクならプレビューに置換する&#10;  useEffect(() =&gt; {&#10;    if (!articleContentRef.current) return;&#10;    const container = articleContentRef.current;&#10;&#10;    // デバッグ: contentWithIds の中身（長さ）を表示&#10;    try {&#10;      // eslint-disable-next-line no-console&#10;      console.log('[ArticlePage] contentWithIds length:', contentWithIds ? String(contentWithIds.length) : 'null/undefined');&#10;    } catch (e) {}&#10;&#10;    const processAnchors = () =&gt; {&#10;      const anchors = Array.from(container.querySelectorAll('a'));&#10;      if (!anchors.length) return;&#10;&#10;      anchors.forEach(a =&gt; {&#10;        try {&#10;          // 既に変換済みなら何もしない（data 属性・クラス・内部構造のいずれかで判定）&#10;          if (a.dataset &amp;&amp; a.dataset.previewApplied) return; // 既に処理済み&#10;          if (a.classList &amp;&amp; (a.classList.contains('external-link') || a.classList.contains('link-preview'))) {&#10;            // 安全のためフラグをセット&#10;            if (a.dataset &amp;&amp; !a.dataset.previewApplied) a.dataset.previewApplied = '1';&#10;            return;&#10;          }&#10;          if (a.querySelector &amp;&amp; (a.querySelector('.ext-inner') || a.querySelector('.link-preview'))) {&#10;            if (a.dataset &amp;&amp; !a.dataset.previewApplied) a.dataset.previewApplied = '1';&#10;            return;&#10;          }&#10;          const href = a.getAttribute('href');&#10;          if (!href) return;&#10;&#10;          // デバッグ&#10;          // eslint-disable-next-line no-console&#10;          console.log('[ArticlePage] processing anchor:', href);&#10;&#10;          const url = new URL(href, window.location.origin);&#10;          const p = url.searchParams.get('p');&#10;          let target = null;&#10;          if (p) {&#10;            target = [...blogPosts, ...cmsArticlesList].find(x =&gt; String(x.slug) === String(p) || String(x.id) === String(p));&#10;          } else {&#10;            const path = url.pathname || '';&#10;            if (path &amp;&amp; path !== '/') {&#10;              const parts = path.split('/').filter(Boolean);&#10;              const last = parts[parts.length - 1];&#10;              if (last) {&#10;                target = [...blogPosts, ...cmsArticlesList].find(x =&gt; String(x.slug) === String(last) || String(x.id) === String(last));&#10;              }&#10;            }&#10;          }&#10;&#10;          if (target) {&#10;            // 内部プレビュー&#10;            const imgSrc = target.image?.url || target.image || '/sample-images/no-image.jpg';&#10;            const wrapper = document.createElement('div');&#10;            wrapper.className = 'link-preview';&#10;&#10;            const img = document.createElement('img');&#10;            img.src = imgSrc;&#10;            img.alt = target.title || '';&#10;            img.onerror = function() { this.src = '/sample-images/no-image.jpg'; };&#10;&#10;            const titleDiv = document.createElement('div');&#10;            titleDiv.className = 'lp-title';&#10;            titleDiv.textContent = target.title || String(target.id || target.slug || href);&#10;&#10;            wrapper.appendChild(img);&#10;            wrapper.appendChild(titleDiv);&#10;&#10;            a.innerHTML = '';&#10;            a.appendChild(wrapper);&#10;            a.classList.add('link-preview');&#10;            a.dataset.previewApplied = '1';&#10;          } else {&#10;            // 外部リンク&#10;            const isHttp = /^https?:/.test(url.protocol);&#10;            const isSameOrigin = url.origin === window.location.origin;&#10;            if (isHttp &amp;&amp; !isSameOrigin) {&#10;              const domain = url.hostname.replace(/^www\./, '');&#10;&#10;              const wrapper = document.createElement('div');&#10;              wrapper.className = 'ext-inner';&#10;&#10;              // ファビコンは表示しない（省略）。meta のみ作成。&#10;              const meta = document.createElement('div');&#10;              meta.className = 'ext-meta';&#10;&#10;              const titleDiv = document.createElement('div');&#10;              titleDiv.className = 'ext-title';&#10;              titleDiv.textContent = a.textContent ? a.textContent.trim() : href;&#10;&#10;              const domainDiv = document.createElement('div');&#10;              domainDiv.className = 'ext-domain';&#10;              domainDiv.textContent = domain;&#10;&#10;              meta.appendChild(titleDiv);&#10;              meta.appendChild(domainDiv);&#10;&#10;              wrapper.appendChild(meta);&#10;&#10;              // 追加: 外部感を示す小さな矢印アイコンを追加&#10;              const arrow = document.createElement('span');&#10;              arrow.className = 'ext-arrow';&#10;              arrow.innerHTML = `&#10;                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; aria-hidden=&quot;true&quot;&gt;&#10;                  &lt;path d=&quot;M5 12h14&quot;&gt;&lt;/path&gt;&#10;                  &lt;path d=&quot;M12 5l7 7-7 7&quot;&gt;&lt;/path&gt;&#10;                &lt;/svg&gt;`;&#10;              wrapper.appendChild(arrow);&#10;&#10;              a.innerHTML = '';&#10;              a.appendChild(wrapper);&#10;              a.classList.add('external-link');&#10;              a.setAttribute('target', '_blank');&#10;              a.setAttribute('rel', 'noopener noreferrer');&#10;              a.dataset.previewApplied = '1';&#10;&#10;              // eslint-disable-next-line no-console&#10;              console.log('[ArticlePage] converted external link:', href, '-&gt;', domain);&#10;            }&#10;          }&#10;        } catch (e) {&#10;          // eslint-disable-next-line no-console&#10;          console.warn('[ArticlePage] anchor processing failed for', a, e);&#10;        }&#10;      });&#10;    };&#10;&#10;    // 初回実行&#10;    processAnchors();&#10;    window.mergeSeparatedExtInner &amp;&amp; window.mergeSeparatedExtInner();&#10;    window.hideTextOnlyExternalAnchors &amp;&amp; window.hideTextOnlyExternalAnchors();&#10;&#10;&#10;    // --- converted: global utility functions for merging/hiding external links ---&#10;    window.mergeSeparatedExtInner = function() {&#10;      try {&#10;        const containerEl = articleContentRef?.current || document.body;&#10;        if (!containerEl) return;&#10;        const inners = Array.from(containerEl.querySelectorAll('.ext-inner'));&#10;        inners.forEach(inner =&gt; {&#10;          // skip if already inside an anchor&#10;          if (inner.closest('a.external-link')) return;&#10;          // find nearest anchor siblings that share the same href&#10;  // hrefCandidates / aSiblings removed (unused)&#10;          // collect anchors that have same href and are adjacent to this inner&#10;          let anchor = null;&#10;          // look back&#10;          let prev = inner.previousElementSibling;&#10;          while(prev) { if (prev.tagName === 'A' &amp;&amp; prev.classList.contains('external-link')) { anchor = prev; break; } prev = prev.previousElementSibling; }&#10;          // look forward if not found&#10;          if (!anchor) { let next = inner.nextElementSibling; while(next) { if (next.tagName === 'A' &amp;&amp; next.classList.contains('external-link')) { anchor = next; break; } next = next.nextElementSibling; } }&#10;          // if anchor still not found, try to find any anchor that has same href as inner's internal anchors&#10;          if (!anchor) { const innerA = inner.querySelector('a.external-link'); const href = innerA ? innerA.getAttribute('href') : null; if (href) { anchor = Array.from(containerEl.querySelectorAll('a.external-link')).find(x=&gt;x.getAttribute('href')===href); } }&#10;          // if still not found, create one and insert before inner&#10;          if (!anchor) { anchor = document.createElement('a'); anchor.className = 'external-link'; const innerA = inner.querySelector('a.external-link'); if (innerA &amp;&amp; innerA.getAttribute('href')) anchor.setAttribute('href', innerA.getAttribute('href')); anchor.setAttribute('target','_blank'); anchor.setAttribute('rel','noopener noreferrer'); anchor.dataset.previewApplied = '1'; inner.parentNode.insertBefore(anchor, inner); }&#10;          // move arrow if exists in adjacent anchor&#10;          const possibleArrowAnchor = inner.nextElementSibling &amp;&amp; inner.nextElementSibling.tagName==='A' &amp;&amp; inner.nextElementSibling.classList.contains('external-link') &amp;&amp; inner.nextElementSibling.querySelector('.ext-arrow') ? inner.nextElementSibling : null;&#10;          if (possibleArrowAnchor) {&#10;            const arrow = possibleArrowAnchor.querySelector('.ext-arrow');&#10;            if (arrow) anchor.appendChild(arrow);&#10;            try { possibleArrowAnchor.parentNode.removeChild(possibleArrowAnchor); } catch (e) {}&#10;          }&#10;          // replace any anchors inside inner with spans to avoid nested anchors&#10;          const innerAnchors = Array.from(inner.querySelectorAll('a.external-link'));&#10;          innerAnchors.forEach(aEl =&gt; { try { const span = document.createElement('span'); span.className = 'ext-link-text'; span.textContent = aEl.textContent || aEl.getAttribute('href') || ''; aEl.parentNode.replaceChild(span, aEl); } catch(e){} });&#10;          // finally append inner into anchor&#10;          try { anchor.appendChild(inner); } catch(e){}&#10;        });&#10;      } catch(e) {}&#10;        };&#10;        window.hideTextOnlyExternalAnchors = function() {&#10;      try {&#10;        const containerEl = articleContentRef?.current || document.body;&#10;        if (!containerEl) return;&#10;        const anchors = Array.from(containerEl.querySelectorAll('a.external-link'));&#10;        anchors.forEach(a =&gt; {&#10;          try {&#10;            // skip anchors that have structured content or arrow inside&#10;            if (a.querySelector('.ext-inner') || a.querySelector('.ext-arrow')) return;&#10;            const href = (a.getAttribute('href') || '').trim();&#10;            const txt = (a.textContent || '').trim();&#10;            if (!href) return;&#10;            if (!txt) { a.style.display = 'none'; return; }&#10;            // if text exactly equals href (or equals href without protocol), hide it&#10;            const noProto = href.replace(/^https?:\/\//, '');&#10;            if (txt === href || txt === noProto) {&#10;              a.style.display = 'none';&#10;            }&#10;          } catch (e) {}&#10;        });&#10;      } catch (e) {}&#10;        };&#10;    &#10;&#10;&#10;    // --- 追加: クライアント側で分離している .ext-inner と隣接する a.external-link を統合する ---&#10;    &#10;&#10;    // --- 追加: テキストだけの a.external-link（URLそのものを表示しているもの）を非表示にする ---&#10;    &#10;&#10;&#10;&#10;&#10;&#10;    // --- 追加: クライアント側で分離している .ext-inner と隣接する a.external-link を統合する ---&#10;    &#10;&#10;    // --- 追加: テキストのみの a.external-link を非表示にする（URLだけのもの） ---&#10;    &#10;&#10;&#10;&#10;&#10;    // MutationObserver で遅延挿入されるリンクに対応する&#10;    let observer = null;&#10;    try {&#10;      observer = new MutationObserver(mutations =&gt; {&#10;        let shouldProcess = false;&#10;        for (const m of mutations) {&#10;          if (m.type === 'childList' &amp;&amp; m.addedNodes &amp;&amp; m.addedNodes.length) {&#10;            shouldProcess = true;&#10;            break;&#10;          }&#10;        }&#10;        if (shouldProcess) {&#10;          // 小さな遅延で再処理&#10;          setTimeout(()=&gt;{ processAnchors(); window.mergeSeparatedExtInner &amp;&amp; window.mergeSeparatedExtInner(); window.hideTextOnlyExternalAnchors &amp;&amp; window.hideTextOnlyExternalAnchors(); }, 50);&#10;        }&#10;      });&#10;      observer.observe(container, { childList: true, subtree: true });&#10;    } catch (e) {&#10;      // 観測に失敗しても問題ない&#10;    }&#10;&#10;    return () =&gt; {&#10;      if (observer) observer.disconnect();&#10;    };&#10;  }, [contentWithIds, cmsArticlesList]);&#10;&#10;  // AdSense広告の初期化&#10;  useEffect(() =&gt; {&#10;    if (window.adsbygoogle &amp;&amp; adRef.current) {&#10;      try {&#10;        window.adsbygoogle.push({});&#10;      } catch (e) {}&#10;    }&#10;  }, [id]);&#10;  // microCMS記事でも関連記事を表示（ローカル+CMS両方から抽出）&#10;  const allArticles = [&#10;    ...blogPosts,&#10;    ...cmsArticlesList&#10;  ];&#10;  // 正規化したカテゴリ名を返すユーティリティ&#10;  function getCategoryName(a) {&#10;    if (!a) return undefined;&#10;    if (a.category &amp;&amp; typeof a.category === 'object') return a.category.name;&#10;    return a.category;&#10;  }&#10;  // 現在の投稿の正規カテゴリ名&#10;  const currentCatName = getCategoryName(post);&#10;  // slug/id を文字列化&#10;  const postSlug = post?.slug ? String(post.slug) : String(post?.id || '');&#10;  const related = allArticles.filter(p =&gt; {&#10;    const pSlug = p.slug ? String(p.slug) : String(p.id || '');&#10;    // カテゴリ名が同じ、かつ自身以外&#10;    return getCategoryName(p) === currentCatName &amp;&amp; pSlug !== postSlug;&#10;  });&#10;&#10;  // ローカル記事もなく、まだ CMS からの取得が終わっていない場合は何も表示しない（フラッシュ防止）&#10;  const hasLocal = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;  if (!post) {&#10;    if (!hasLocal &amp;&amp; cmsArticle === undefined) {&#10;      // loading: 表示を出さずフラッシュを防止&#10;      return null;&#10;    }&#10;    // 取得済みだが存在しない場合はメッセージ表示&#10;    return &lt;ArticleContainer&gt;記事が見つかりませんでした。&lt;/ArticleContainer&gt;;&#10;  }&#10;&#10;&#10;  return (&#10;    &lt;&gt;&#10;  {/* EyeCatch削除: 記事ごとの画像のみ表示 */}&#10;      &lt;ArticleContainer&gt;&#10;        &lt;ArticleTitle&gt;{post.title}&lt;/ArticleTitle&gt;&#10;        &lt;div style={{display:'flex', justifyContent:'center', position: 'relative'}}&gt;&#10;          {/* 日付を画像の上、右寄せでオーバーレイ表示 */}&#10;          {publishedDate &amp;&amp; (&#10;            &lt;ArticleDate&gt;&#10;              {publishedDate} に公開&#10;            &lt;/ArticleDate&gt;&#10;          )}&#10;          &lt;ArticleImageEyeCatch src={imageUrl} alt={post.title} className={isVertical ? 'vertical' : ''} /&gt;&#10;        &lt;/div&gt;&#10;        {/* 目次 */}&#10;        {toc.length &gt; 0 &amp;&amp; (&#10;          &lt;TocContainer aria-label=&quot;目次&quot;&gt;&#10;            &lt;strong style={{color:'#1B5E20'}}&gt;目次&lt;/strong&gt;&#10;            &lt;TocList&gt;&#10;              {toc.map(item =&gt; (&#10;                &lt;TocItem key={item.id} className={`toc-${item.tag}`}&gt;&#10;                  &lt;TocLink href={`#${item.id}`}&gt;{item.text}&lt;/TocLink&gt;&#10;                &lt;/TocItem&gt;&#10;              ))}&#10;            &lt;/TocList&gt;&#10;          &lt;/TocContainer&gt;&#10;        )}&#10;        &lt;ArticleContent ref={articleContentRef} dangerouslySetInnerHTML={{ __html: contentWithIds }} /&gt;&#10;        {/* Google AdSense in-article広告ユニット */}&#10;        &lt;div style={{margin: '32px 0', display: 'flex', justifyContent: 'center'}}&gt;&#10;          &lt;ins className=&quot;adsbygoogle&quot;&#10;            style={{ display: 'block', textAlign: 'center' }}&#10;            data-ad-layout=&quot;in-article&quot;&#10;            data-ad-format=&quot;fluid&quot;&#10;            data-ad-client=&quot;ca-pub-7728107798566122&quot;&#10;            data-ad-slot=&quot;5951785085&quot;&#10;            ref={adRef}&#10;          &gt;&lt;/ins&gt;&#10;        &lt;/div&gt;&#10;        {related.length &gt; 0 &amp;&amp; (&#10;          &lt;RelatedSection&gt;&#10;            &lt;RelatedTitle&gt;&lt;FaLink /&gt; 関連ページ&lt;/RelatedTitle&gt;&#10;            &lt;RelatedList&gt;&#10;              {related.map(r =&gt; {&#10;                const relImg = r.image?.url || r.image;&#10;                const relLink = `/?p=${r.slug || r.id}`;&#10;                return (&#10;                  &lt;RelatedCard to={relLink} key={r.slug || r.id}&gt;&#10;                    &lt;RelatedImage src={relImg} alt={r.title} /&gt;&#10;                    &lt;RelatedCardTitle&gt;{r.title}&lt;/RelatedCardTitle&gt;&#10;                  &lt;/RelatedCard&gt;&#10;                );&#10;              })}&#10;             &lt;/RelatedList&gt;&#10;           &lt;/RelatedSection&gt;&#10;         )}&#10;        &lt;BackLink to=&quot;/&quot;&gt;&#10;          &lt;FaArrowLeft /&gt; トップページへ戻る&#10;        &lt;/BackLink&gt;&#10;      &lt;/ArticleContainer&gt;&#10;    &lt;/&gt;&#10;  );&#10;};&#10;&#10;export default ArticlePage;&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useRef, useMemo } from 'react';&#10;import { Link } from 'react-router-dom';&#10;import styled from '@emotion/styled';&#10;import { theme } from '../styles/theme';&#10;import { FaLink, FaArrowLeft } from 'react-icons/fa';&#10;import { fetchArticleById, fetchArticles } from '../api/microcms';&#10;&#10;// JSONファイルを一括取得（記事一覧を作るため）&#10;function importAllJson(r) {&#10;  return r.keys().map(key =&gt; {&#10;    const data = r(key);&#10;    return {&#10;      id: data.id || data.slug || key.replace(/^.*[/]/, '').replace(/\.json$/, ''),&#10;      ...data&#10;    };&#10;  });&#10;}&#10;&#10;const jsonArticles = importAllJson(require.context('../articles', false, /\.json$/));&#10;&#10;// blogPosts: HomePage/CategoryPageと同じローカル記事配列を定義&#10;const blogPosts = [&#10;  ...jsonArticles&#10;  // 必要ならここにjs記事やテスト記事を追加可能&#10;];&#10;&#10;&#10;// Google AdSense script を head に挿入するユーティリティ（重複挿入を防止）&#10;function useAdsenseScript() {&#10;  // 実行環境でのみ DOM にスクリプトを挿入&#10;  try {&#10;    if (typeof document === 'undefined') return;&#10;    if (!document.querySelector('script[src*=&quot;adsbygoogle.js?client=ca-pub-7728107798566122&quot;]')) {&#10;      const script = document.createElement('script');&#10;      script.async = true;&#10;      script.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7728107798566122';&#10;      script.crossOrigin = 'anonymous';&#10;      document.head.appendChild(script);&#10;    }&#10;  } catch (e) {&#10;    // サーバーサイド環境やテスト環境では無視&#10;  }&#10;}&#10;&#10;// 目次生成関数&#10;function generateTocAndContent(html) {&#10;  if (!html) return { toc: [], html };&#10;  let idx = 0;&#10;  const toc = [];&#10;  // h2/h3タグにidを付与しつつtoc配列を作る&#10;  let newHtml = html.replace(/&lt;(h[23])([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g, (match, tag, attrs, text) =&gt; {&#10;    const cleanText = text.replace(/&lt;[^&gt;]+&gt;/g, '');&#10;    const id = `heading-${tag}-${idx++}`;&#10;    toc.push({ tag, text: cleanText, id });&#10;    return `&lt;${tag} id=&quot;${id}&quot;${attrs}&gt;${text}&lt;/${tag}&gt;`;&#10;  });&#10;  // imgタグのsrcが/contents/で始まる場合、絶対パスに補正&#10;  newHtml = newHtml.replace(/&lt;img([^&gt;]*?)src=[&quot;'](\/contents\/[^&quot;'&gt;]+)[&quot;']([^&gt;]*)&gt;/g, (match, before, src, after) =&gt; {&#10;    return `&lt;img${before}src=&quot;${src}&quot;${after}&gt;`;&#10;  });&#10;&#10;  // --- 追加: img の inline 属性(width/height/style) を削除し class=&quot;cms-image&quot; を付与 ---&#10;  newHtml = newHtml.replace(/&lt;img([^&gt;]*)&gt;/g, (match, attrs) =&gt; {&#10;    // attrs 部から width, height, style を削除&#10;    let cleaned = attrs.replace(/\s*(width|height)=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    cleaned = cleaned.replace(/\s*style=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    // class があれば追記、なければ追加&#10;    if (/class=/.test(cleaned)) {&#10;      cleaned = cleaned.replace(/class=(&quot;|')(.*?)(&quot;|')/i, (m, q, cls) =&gt; `class=${q}${cls} cms-image${q}`);&#10;    } else {&#10;      cleaned = `${cleaned} class=&quot;cms-image&quot;`;&#10;    }&#10;    return `&lt;img${cleaned}&gt;`;&#10;  });&#10;&#10;  // --- 追加: Google Maps のリンクを短いラベルに置換して target/rel を付与 ---&#10;  newHtml = newHtml.replace(/&lt;a([^&gt;]*href=[&quot;'][^&quot;']*google\.com\/maps[^&quot;']*[&quot;'][^&gt;]*)&gt;(.*?)&lt;\/a&gt;/gi, (match, attrs, inner) =&gt; {&#10;    let cleaned = attrs.replace(/\s*target=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    cleaned = cleaned.replace(/\s*rel=[&quot;'][^&quot;']*[&quot;']/gi, '');&#10;    return `&lt;a${cleaned} target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt; Googleマップ&lt;/a&gt;`;&#10;  });&#10;&#10;  // --- 追加: ブラウザ環境では DOMParser を使って外部リンクをカードに変換 ---&#10;  try {&#10;    if (typeof window !== 'undefined' &amp;&amp; typeof window.DOMParser !== 'undefined') {&#10;      const parser = new DOMParser();&#10;      const doc = parser.parseFromString(newHtml, 'text/html');&#10;      const anchors = Array.from(doc.querySelectorAll('a'));&#10;      anchors.forEach(a =&gt; {&#10;        try {&#10;          const href = a.getAttribute('href');&#10;          if (!href) return;&#10;          const url = new URL(href, window.location.origin);&#10;          const isHttp = /^https?:/.test(url.protocol);&#10;          const isSameOrigin = url.origin === window.location.origin;&#10;          if (isHttp &amp;&amp; !isSameOrigin) {&#10;            const domain = url.hostname.replace(/^www\./, '');&#10;            // 既に同じ href の external-link が container 内にあれば重複作成をスキップ&#10;              try {&#10;                const existing = doc.querySelector(`a.external-link[href=&quot;${href}&quot;]`);&#10;                if (existing) {&#10;                  if (a.dataset) a.dataset.previewApplied = '1';&#10;                  return;&#10;                }&#10;              } catch (e) { }&#10;&#10;&#10;            // ext-inner を作って内部を構築&#10;            const wrapper = doc.createElement('div');&#10;            wrapper.className = 'ext-inner';&#10;&#10;            // ファビコンは表示しない（省略）: meta のみ作成&#10;            const meta = doc.createElement('div');&#10;            meta.className = 'ext-meta';&#10;&#10;            const titleDiv = doc.createElement('div');&#10;            titleDiv.className = 'ext-title';&#10;            titleDiv.textContent = a.textContent ? a.textContent.trim() : href;&#10;&#10;            const domainDiv = doc.createElement('div');&#10;            domainDiv.className = 'ext-domain';&#10;            domainDiv.textContent = domain;&#10;&#10;            meta.appendChild(titleDiv);&#10;            meta.appendChild(domainDiv);&#10;&#10;            // wrapper の順序: メタのみ（ファビコンなし）&#10;            wrapper.appendChild(meta);&#10;&#10;            // 追加: 外部感を示す小さな矢印アイコンを追加&#10;            const arrow = doc.createElement('span');&#10;            arrow.className = 'ext-arrow';&#10;            arrow.innerHTML = `&#10;              &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; aria-hidden=&quot;true&quot;&gt;&#10;                &lt;path d=&quot;M5 12h14&quot;&gt;&lt;/path&gt;&#10;                &lt;path d=&quot;M12 5l7 7-7 7&quot;&gt;&lt;/path&gt;&#10;              &lt;/svg&gt;`;&#10;            wrapper.appendChild(arrow);&#10;&#10;            // アンカー自体を外部リンク表示に調整&#10;            a.innerHTML = '';&#10;            a.appendChild(wrapper);&#10;            // preserve existing classes and add external-link&#10;            a.className = (a.className ? a.className + ' external-link' : 'external-link');&#10;            a.setAttribute('target', '_blank');&#10;            a.setAttribute('rel', 'noopener noreferrer');&#10;            // 変換済みフラグを付与（クライアント側処理の重複を避けるため）&#10;            a.setAttribute('data-preview-applied', '1');&#10;          }&#10;        } catch (e) {&#10;          // 個別アンカーの変換エラーは無視&#10;        }&#10;      });&#10;      // --- 追加: サーバ側で同一 href の external-link を重複削除 ---&#10;      try {&#10;        const seen = new Set();&#10;        const anchorsAll = Array.from(doc.querySelectorAll('a.external-link'));&#10;        anchorsAll.forEach(el =&gt; {&#10;          try {&#10;            const href0 = el.getAttribute('href');&#10;            if (!href0) return;&#10;            if (seen.has(href0)) {&#10;              el.parentNode &amp;&amp; el.parentNode.removeChild(el);&#10;            } else {&#10;              seen.add(href0);&#10;            }&#10;          } catch (e) {}&#10;        });&#10;      } catch (e) {}&#10;&#10;      // シリアライズして戻す&#10;      newHtml = doc.body.innerHTML;// シリアライズして戻す&#10;      newHtml = doc.body.innerHTML;&#10;    }&#10;  } catch (e) {&#10;    // DOMParser 系のエラーは無視して元の newHtml を返す&#10;  }&#10;&#10;  return { toc, html: newHtml };&#10;}&#10;&#10;const TocList = styled.ul`&#10;  list-style: none;&#10;  margin: 0;&#10;  padding: 0;&#10;`;&#10;const TocItem = styled.li`&#10;  margin: 0.2em 0 0.2em 0.5em;&#10;  &amp;.toc-h3 { margin-left: 1.5em; font-size: 0.95em; }&#10;`;&#10;const TocLink = styled.a`&#10;  color: #2E7D32;&#10;  text-decoration: none;&#10;  &amp;:hover { text-decoration: underline; color: #1B5E20; }&#10;`;&#10;&#10;&#10;// 目次(Toc)コンポーネント&#10;const TocContainer = styled.nav`&#10;  background: #f6fff6;&#10;  border: 2px solid #2E7D32;&#10;  border-radius: 12px;&#10;  padding: 1em 1.5em;&#10;  margin: 2em auto 2em auto;&#10;  font-size: 0.98rem;&#10;  width: 60%;&#10;  max-width: 500px;&#10;  min-width: 220px;&#10;  box-sizing: border-box;&#10;  display: block;&#10;  @media (max-width: 600px) {&#10;    width: 80vw;&#10;    font-size: 0.92rem;&#10;    padding: 0.7em 0.7em;&#10;  }&#10;`;&#10;const ArticleContent = styled.div`&#10;  /* CONSOLIDATED: external-link unified card */&#10;&#10;  /* Support standalone .ext-inner (server-produced) to display as unified card) */&#10;  .ext-inner {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.9rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    position: relative;&#10;    overflow: hidden;&#10;  }&#10;  /* Hide fully empty external-link anchors (e.g. stray anchors) */&#10;  a.external-link:empty { display: none; }&#10;  /* If an arrow anchor is a sibling after .ext-inner, visually overlap it on the card's right */&#10;  .ext-inner + a.external-link {&#10;    display: inline-flex;&#10;    align-items: center;&#10;    justify-content: center;&#10;    width: 40px;&#10;    margin-left: -40px; /* overlap into card */&#10;    padding: 0;&#10;    background: transparent;&#10;    border: none;&#10;  }&#10;  .ext-inner + a.external-link .ext-arrow {&#10;    position: relative;&#10;    right: 0;&#10;    top: 0;&#10;    transform: none;&#10;    width: 16px;&#10;    height: 16px;&#10;    display: block;&#10;    color: #2E7D32;&#10;  }&#10;&#10;  .external-link {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.9rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    text-decoration: none;&#10;    color: inherit;&#10;    transition: transform 0.12s ease, box-shadow 0.12s ease;&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    overflow: hidden;&#10;    position: relative;&#10;  }&#10;  .external-link:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,128,64,0.08); }&#10;  .external-link .ext-inner { display:flex; flex-direction:row; align-items:center; gap:0.8rem; width:100%; min-width:0; flex:1 1 auto; padding-right:40px; }&#10;  .external-link .ext-meta { display:flex; flex-direction:column; min-width:0; flex:1 1 auto; overflow:hidden; }&#10;  .external-link .ext-title { font-weight:700; color: #2E7D32; font-size:0.95rem; line-height:1.25; white-space:normal; overflow:hidden; text-overflow:ellipsis; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; }&#10;  .external-link .ext-domain { font-size:0.78rem; color: #21212188; margin-top:0.18rem; white-space:normal; word-break:break-all; }&#10;  .external-link .ext-arrow { position:absolute; right:12px; top:50%; transform:translateY(-50%); width:16px; height:16px; display:flex; align-items:center; justify-content:center; color:#2E7D32; pointer-events:none; }&#10;  .external-link .ext-arrow svg { width:100%; height:100%; display:block; stroke:currentColor; vector-effect:non-scaling-stroke; }&#10;  @media (max-width:600px) { .external-link{padding:0.36rem 0.6rem;} .external-link .ext-inner{gap:0.6rem; padding-right:36px;} .external-link .ext-title{font-size:0.92rem; -webkit-line-clamp:2;} .external-link .ext-domain{font-size:0.75rem;} .external-link .ext-arrow{right:10px; width:14px; height:14px;} }&#10;&#10;&#10;  color: ${theme.colors.text};&#10;  font-size: 1.0rem; /* 基本フォントを小さめに調整 */&#10;  line-height: 1.7;&#10;  font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;&#10;  /* 本文内リンクの折り返しと最大幅制御 */&#10;  a {&#10;    overflow-wrap: anywhere;&#10;    word-break: break-word;&#10;    display: inline-block;&#10;    max-width: 100%;&#10;  }&#10;&#10;  /* リンクプレビュー用スタイル */&#10;  .link-preview {&#10;    display: flex;&#10;    gap: 0.8em;&#10;    align-items: center;&#10;    border: 1px solid #e6f4ea;&#10;    background: transparent;&#10;    padding: 0.4rem;&#10;    border-radius: 8px;&#10;    margin-top: 0.6rem;&#10;    text-decoration: none;&#10;    color: inherit;&#10;  }&#10;  .link-preview img {&#10;    width: 84px;&#10;    height: 56px;&#10;    object-fit: cover;&#10;    border-radius: 6px;&#10;    flex-shrink: 0;&#10;    background: transparent;&#10;  }&#10;  .link-preview .lp-title {&#10;    font-weight: 700;&#10;    color: ${theme.colors.primary};&#10;    font-size: 0.92rem;&#10;    line-height: 1.2;&#10;  }&#10;&#10;  /* 追加: 外部リンク用のカード表示 */&#10;  .external-link_obsolete {&#10;    display: block; /* anchor をブロックにして横幅いっぱいのカードにする */&#10;    border: 1px solid #e9f5ef;&#10;    background: linear-gradient(180deg,#ffffff,#f8fff8);&#10;    padding: 0.45rem 0.6rem;&#10;    border-radius: 10px;&#10;    margin: 0.6rem 0;&#10;    text-decoration: none;&#10;    color: inherit;&#10;    transition: transform 0.12s ease, box-shadow 0.12s ease;&#10;    width: 100%;&#10;    box-sizing: border-box; /* はみ出し防止 */&#10;    overflow: hidden;&#10;  }&#10;  .external-link_obsolete:hover { transform: translateY(-4px); box-shadow: 0 8px 20px rgba(0,128,64,0.08); }&#10;&#10;  /* 内部コンテナを横並びにする（左: favicon、右: meta） */&#10;  .external-link_obsolete .ext-inner{&#10;    display: flex;&#10;    flex-direction: row;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    width: 100%;&#10;    padding-right: 28px; /* 右端の矢印分の余白を確保（ファビコン無しで少し小さめ） */&#10;  }&#10;  .external-link_obsolete .ext-meta { display: flex; flex-direction: column; min-width: 0; flex: 1 1 auto; }&#10;  .external-link_obsolete .ext-title { font-weight: 700; color: ${theme.colors.primary}; font-size: 0.95rem; white-space: normal; overflow: visible; word-break: break-word; }&#10;  .external-link_obsolete .ext-domain { font-size: 0.75rem; color: ${theme.colors.text}99; margin-top: 0.18rem; white-space: normal; color: ${theme.colors.text}88; }&#10;&#10;  /* モバイル（小さい画面）での折返し対応 */&#10;  @media (max-width: 600px) {&#10;    .external-link_obsolete {&#10;      padding: 0.36rem 0.5rem;&#10;      gap: 0.6rem;&#10;      align-items: flex-start;&#10;      /* ext-inner が折り返す */&#10;    }&#10;    .external-link_obsolete .ext-favicon {&#10;      width: 28px !important;&#10;      height: 28px !important;&#10;    }&#10;    .external-link_obsolete .ext-meta { min-width: 0; }&#10;    .external-link_obsolete .ext-title {&#10;      white-space: normal; /* 折り返す */&#10;      font-size: 0.92rem;&#10;      line-height: 1.2;&#10;      overflow: visible;&#10;    }&#10;    .external-link_obsolete .ext-domain {&#10;      white-space: normal;&#10;      word-break: break-all; /* ドメインが長い場合に折り返す */&#10;      color: ${theme.colors.text}88;&#10;    }&#10;  }&#10;&#10;  /* 既存スタイル続行 */&#10;  h2 {&#10;    color: ${theme.colors.primary};&#10;    font-size: 1.3rem;&#10;    border-left: 7px solid ${theme.colors.primary};&#10;    border-radius: 0 12px 12px 0;&#10;    padding-left: 0.7em;&#10;    margin: 2em 0 1em 0;&#10;    font-weight: bold;&#10;    background: #f6fff6;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  h3 {&#10;    color: ${theme.colors.secondary};&#10;    font-size: 1.1rem;&#10;    margin: 1.5em 0 0.7em 0;&#10;    font-weight: bold;&#10;    border-left: 5px solid ${theme.colors.secondary};&#10;    border-radius: 0 10px 10px 0;&#10;    padding-left: 0.6em;&#10;    background: #eaffea;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  h4 {&#10;    color: ${theme.colors.accent};&#10;    font-size: 1.05rem;&#10;    margin: 1.2em 0 0.5em 0;&#10;    font-weight: bold;&#10;    border-left: 4px dashed ${theme.colors.accent};&#10;    border-radius: 0 8px 8px 0;&#10;    padding-left: 0.5em;&#10;    background: #f9fff6;&#10;    font-family: 'Rounded Mplus 1c', 'Noto Sans JP', 'Meiryo', 'Hiragino Maru Gothic Pro', Arial, sans-serif;&#10;  }&#10;  strong, .em {&#10;    color: ${theme.colors.highlight};&#10;    background: #fffbe6;&#10;    font-weight: bold;&#10;    padding: 0 0.2em;&#10;    border-radius: 4px;&#10;  }&#10;&#10;  /* 本文内画像をコンテナ内に収める */&#10;  img.cms-image,&#10;  .cms-image {&#10;    border-radius: 16px;&#10;    width: 100% !important;&#10;    /* 元の表示: コンテナ幅に合わせて最大化（はみ出さない） */&#10;    max-width: 100% !important;&#10;    height: auto !important;&#10;    object-fit: contain;&#10;    box-shadow: 0 2px 8px rgba(0,0,0,0.07);&#10;    margin: 1.6em auto;&#10;    display: block;&#10;    background: transparent;&#10;    padding: 0;&#10;  }&#10;&#10;  /* デスクトップではコンテナ幅いっぱいに見せる（ブリードは行わない） */&#10;  @media (min-width: 900px) {&#10;    img.cms-image, .cms-image {&#10;      width: 100% !important;&#10;      max-width: 100% !important;&#10;      border-radius: 16px;&#10;    }&#10;  }&#10;&#10;  /* 横長カードを確実にするための微調整 */&#10;  .external-link_obsolete {&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 0.8rem;&#10;    width: 100%;&#10;    position: relative; /* 矢印を絶対配置で右端中央にするため */&#10;  }&#10;&#10;  /* タブレット/モバイル: コンテナ幅内で表示（はみ出し防止） */&#10;  @media (max-width: 900px) {&#10;    img.cms-image,&#10;    .cms-image {&#10;      width: 100% !important;&#10;      max-width: 100% !important;&#10;      box-sizing: border-box;&#10;      margin-top: 1.4em;&#10;      margin-bottom: 1.4em;&#10;      padding: 0;&#10;      border-radius: 12px;&#10;    }&#10;    /* ファビコン等の小画像は小さく表示 */&#10;    img.ext-favicon { width: auto !important; max-width: 48px !important; margin-left: 0 !important; margin-right: 0 !important; border-radius: 6px; }&#10;  }&#10;&#10;  /* モバイルでは画像を少しはみ出させて目立たせつつ中央寄せ */&#10;  @media (max-width: 600px) {&#10;    font-size: 1.02rem; /* モバイルでも少し小さめに */&#10;    img.cms-image,&#10;    img:not(.ext-favicon) {&#10;      /* コンテナ幅いっぱいに表示（はみ出さない） */&#10;      width: 100% !important;&#10;      max-width: 100% !important;&#10;      margin: 1.2em 0;&#10;      transform: none;&#10;      border-radius: 12px;&#10;      display: block;&#10;      box-sizing: border-box;&#10;      padding: 0;&#10;    }&#10;  }&#10;&#10;  /* 見出しが長い単語やURLで幅を超えないように折返しを強制 */&#10;  h2, h3, h4 {&#10;    white-space: normal;&#10;    word-break: break-word;&#10;    overflow-wrap: anywhere;&#10;  }&#10;&#10;  /* 追加: 外部リンクカードに矢印アイコンを表示 */&#10;  .external-link_obsolete .ext-arrow {&#10;    position: absolute;&#10;    right: 12px;&#10;    top: 50%;&#10;    transform: translateY(-50%);&#10;    width: 16px;&#10;    height: 16px;&#10;    display: flex;&#10;    align-items: center;&#10;    justify-content: center;&#10;    color: ${theme.colors.primary};&#10;    pointer-events: none; /* アイコン自体はクリック対象にしない（アンカー全体がリンク） */&#10;  }&#10;  .external-link_obsolete .ext-arrow svg {&#10;    width: 100%;&#10;    height: 100%;&#10;    display: block;&#10;    stroke: currentColor;&#10;    vector-effect: non-scaling-stroke;&#10;  }&#10;  /* モバイル用: 矢印アイコンを小さく */&#10;  @media (max-width: 600px) {&#10;    .external-link_obsolete .ext-arrow {&#10;      right: 10px;&#10;      width: 14px;&#10;      height: 14px;&#10;    }&#10;  }&#10;&#10;  /* ここから表示幅を広げる調整 */&#10;  /* 元は width: 60%; max-width: 500px; min-width: 220px; */&#10;  width: 100%;&#10;  max-width: none;&#10;  min-width: 0;&#10;  margin-left: 0;&#10;  margin-right: 0;&#10;  box-sizing: border-box;&#10;&#10;  @media (max-width: 1000px) {&#10;    width: 92%;&#10;    max-width: 920px;&#10;    font-size: 0.98rem;&#10;    padding: 0.8em 0.8em;&#10;  }&#10;  @media (max-width: 600px) {&#10;    /* コンテナ内での100%幅にして親のパディングに合わせる（vw を使うと親の余白と衝突してはみ出す） */&#10;    width: 100%;&#10;    box-sizing: border-box;&#10;    font-size: 0.92rem;&#10;    padding: 0.7em 0.7em;&#10;  }&#10;`;&#10;&#10;const ArticleContainer = styled.div`&#10;  width: 70vw;&#10;  max-width: 1100px;&#10;  min-width: 320px;&#10;  margin: 40px auto;&#10;  background: transparent;&#10;  border-radius: 8px;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.08);&#10;  padding: ${theme.spacing.xlarge};&#10;  @media (max-width: 900px) {&#10;    width: 90vw;&#10;    max-width: 98vw;&#10;    padding: ${theme.spacing.large};&#10;  }&#10;`;&#10;const ArticleTitle = styled.h1`&#10;  font-size: 1.2rem; // 小さめに変更&#10;  color: ${theme.colors.primary};&#10;  margin-bottom: ${theme.spacing.medium};&#10;`;&#10;const ArticleImageEyeCatch = styled.img`&#10;  width: 100%;&#10;  aspect-ratio: 4 / 3;&#10;  object-fit: cover;&#10;  border-radius: 18px;&#10;  box-shadow: 0 2px 8px rgba(0,0,0,0.13);&#10;  background: transparent;&#10;  margin-bottom: 1.5em;&#10;`;&#10;// 小さく表示する日付コンポーネント（アイキャッチ上に右寄せでオーバーレイ表示）&#10;const ArticleDate = styled.div`&#10;  font-size: 0.65rem; /* かなり小さく */&#10;  color: #444;&#10;  text-align: right;&#10;  position: absolute;&#10;  top: 8px; /* アイキャッチ右上に配置 */&#10;  right: 10px;&#10;  background: rgba(255,255,255,0.85);&#10;  padding: 0.12rem 0.4rem;&#10;  border-radius: 8px;&#10;  box-shadow: 0 1px 4px rgba(0,0,0,0.06);&#10;  z-index: 6;&#10;`;&#10;&#10;// 追加: アイキャッチ上に表示するタグのコンテナとバッジ&#10;// （記事ページではタグ表示不要のため削除）&#10;&#10;const BackLink = styled(Link)`&#10;  display: inline-flex;&#10;  align-items: center;&#10;  gap: 0.5em;&#10;  margin-top: ${theme.spacing.large};&#10;  color: ${theme.colors.primary};&#10;  text-decoration: none;&#10;  font-weight: bold;&#10;  font-size: 1.05rem;&#10;  background: #f6fff6;&#10;  border-radius: 6px;&#10;  padding: 0.5em 1.2em;&#10;  box-shadow: 0 2px 8px rgba(0,128,64,0.07);&#10;  border: 1.5px solid ${theme.colors.primary}33;&#10;  transition: background 0.2s, color 0.2s, border 0.2s;&#10;  &amp;:hover {&#10;    background: ${theme.colors.primary};&#10;    color: #fff;&#10;    border-color: ${theme.colors.primary};&#10;  }&#10;`;&#10;&#10;// 関連記事リスト&#10;const RelatedSection = styled.div`&#10;  margin-top: 48px;&#10;  text-align: center;&#10;`;&#10;const RelatedTitle = styled.h3`&#10;  color: ${theme.colors.primary};&#10;  font-size: 1.3rem;&#10;  font-weight: bold;&#10;  display: flex;&#10;  align-items: center;&#10;  justify-content: center;&#10;  gap: 0.5em;&#10;  margin-bottom: 1.5em;&#10;`;&#10;const RelatedList = styled.div`&#10;  display: flex;&#10;  flex-wrap: wrap;&#10;  justify-content: center;&#10;  gap: 2em;&#10;`;&#10;const RelatedCard = styled(Link)`&#10;  display: flex;&#10;  flex-direction: row;&#10;  align-items: center;&#10;  width: 640px; /* 横幅を広げる */&#10;  max-width: calc(100% - 40px);&#10;  min-height: 130px; /* 縦に少し広げる */&#10;  background: #f6fff6;&#10;  border-radius: 12px;&#10;  box-shadow: 0 3px 12px rgba(0,0,0,0.08);&#10;  text-decoration: none;&#10;  transition: box-shadow 0.2s, transform 0.12s;&#10;  border: 2px solid ${theme.colors.primary}22;&#10;  padding: 0.9em;&#10;  gap: 1em;&#10;  &amp;:hover {&#10;    transform: translateY(-4px);&#10;    box-shadow: 0 8px 28px rgba(0,128,64,0.14);&#10;    border-color: ${theme.colors.primary};&#10;  }&#10;  @media (max-width: 900px) {&#10;    width: calc(100% - 48px);&#10;  }&#10;  @media (max-width: 600px) {&#10;    width: calc(100% - 32px);&#10;    padding: 0.6em;&#10;    min-height: 110px;&#10;  }&#10;`;&#10;const RelatedImage = styled.img`&#10;  width: 44%; /* 画像幅を大きくして目立たせる */&#10;  aspect-ratio: 4 / 3;&#10;  object-fit: cover;&#10;  border-radius: 12px;&#10;  margin: 0;&#10;  flex-shrink: 0;&#10;`;&#10;const RelatedCardTitle = styled.div`&#10;  color: ${theme.colors.primary};&#10;  font-weight: 700;&#10;  font-size: 0.8rem;&#10;  text-align: left;&#10;  margin: 0;&#10;  line-height: 1.25;&#10;  word-break: break-word; /* 長い単語を折り返す */&#10;  white-space: normal; /* 折り返し許可 */&#10;`;&#10;&#10;const ArticlePage = (props) =&gt; {&#10;  useAdsenseScript();&#10;  const adRef = useRef(null);&#10;  const id = props.id;&#10;  // undefined = 未取得（loading）、object = 取得済、 null = 取得失敗（見つからない）&#10;&#10;  const [cmsArticle, setCmsArticle] = React.useState(undefined);&#10;  // microCMS の記事リスト（関連記事抽出用）&#10;  const [cmsArticlesList, setCmsArticlesList] = React.useState([]);&#10;  // アイキャッチ画像の縦横判定フックは必ず呼ぶ&#10;  const [isVertical, setIsVertical] = React.useState(false);&#10;  // postはuseMemoで取得されるため、imageUrlは毎回計算&#10;  const post = useMemo(() =&gt; {&#10;    // まずローカル記事を探す&#10;    const local = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;    if (local) return local;&#10;    // ローカルに無ければ microCMS記事（APIで取得結果）を返す&#10;    return cmsArticle;&#10;  }, [id, cmsArticle]);&#10;  const imageUrl = post?.image?.url || post?.image;&#10;&#10;  // ref: 本文コンテナを直接操作してリンクプレビュー挿入&#10;  const articleContentRef = useRef(null);&#10;&#10;  React.useEffect(() =&gt; {&#10;    // フックは必ず呼ばれる（条件分岐なし）&#10;    if (!imageUrl) {&#10;      setIsVertical(false);&#10;      return;&#10;    }&#10;    const img = new window.Image();&#10;    img.src = imageUrl;&#10;    img.onload = function() {&#10;      if (img.naturalHeight &gt; img.naturalWidth * 1.15) {&#10;        setIsVertical(true);&#10;      } else {&#10;        setIsVertical(false);&#10;      }&#10;    };&#10;  }, [imageUrl]);&#10;&#10;  // --- 追加: 記事の公開日 / 作成日 を安全に拾って日本ロケールで整形 ---&#10;  const publishedRaw = post?.publishedAt || post?.createdAt || post?.date || post?.published;&#10;  const publishedDate = publishedRaw&#10;    ? new Date(publishedRaw).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })&#10;    : null;&#10;&#10;  // 目次とid付きHTML生成（useEffectより前に定義しておく）&#10;  const { toc, html: contentWithIds } = useMemo(() =&gt; generateTocAndContent(post?.content), [post]);&#10;&#10;  useEffect(() =&gt; {&#10;    window.scrollTo(0, 0);&#10;    // ローカル記事がなければmicroCMS APIで取得（未取得フラグをセット）&#10;    const local = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;    if (!local) {&#10;      setCmsArticle(undefined); // loading&#10;      fetchArticleById(id).then(data =&gt; setCmsArticle(data)).catch(() =&gt; setCmsArticle(null));&#10;    } else {&#10;      // ローカル記事がある場合は CMS 側の状態をクリア&#10;      setCmsArticle(null);&#10;    }&#10;    // 関連記事抽出のため microCMS の一覧を取得（軽量）&#10;    fetchArticles().then(data =&gt; {&#10;      if (data &amp;&amp; Array.isArray(data.contents)) {&#10;        setCmsArticlesList(data.contents);&#10;      }&#10;    }).catch(() =&gt; {});&#10;  }, [id]);&#10;&#10;  // 記事本文の HTML に含まれるリンクを検出し、同一サイト内の記事リンクならプレビューに置換する&#10;  useEffect(() =&gt; {&#10;    if (!articleContentRef.current) return;&#10;    const container = articleContentRef.current;&#10;&#10;    // デバッグ: contentWithIds の中身（長さ）を表示&#10;    try {&#10;      // eslint-disable-next-line no-console&#10;      console.log('[ArticlePage] contentWithIds length:', contentWithIds ? String(contentWithIds.length) : 'null/undefined');&#10;    } catch (e) {}&#10;&#10;    const processAnchors = () =&gt; {&#10;      const anchors = Array.from(container.querySelectorAll('a'));&#10;      if (!anchors.length) return;&#10;&#10;      anchors.forEach(a =&gt; {&#10;        try {&#10;          // 既に変換済みなら何もしない（data 属性・クラス・内部構造のいずれかで判定）&#10;          if (a.dataset &amp;&amp; a.dataset.previewApplied) return; // 既に処理済み&#10;          if (a.classList &amp;&amp; (a.classList.contains('external-link') || a.classList.contains('link-preview'))) {&#10;            // 安全のためフラグをセット&#10;            if (a.dataset &amp;&amp; !a.dataset.previewApplied) a.dataset.previewApplied = '1';&#10;            return;&#10;          }&#10;          if (a.querySelector &amp;&amp; (a.querySelector('.ext-inner') || a.querySelector('.link-preview'))) {&#10;            if (a.dataset &amp;&amp; !a.dataset.previewApplied) a.dataset.previewApplied = '1';&#10;            return;&#10;          }&#10;          const href = a.getAttribute('href');&#10;          if (!href) return;&#10;&#10;          // デバッグ&#10;          // eslint-disable-next-line no-console&#10;          console.log('[ArticlePage] processing anchor:', href);&#10;&#10;          const url = new URL(href, window.location.origin);&#10;          const p = url.searchParams.get('p');&#10;          let target = null;&#10;          if (p) {&#10;            target = [...blogPosts, ...cmsArticlesList].find(x =&gt; String(x.slug) === String(p) || String(x.id) === String(p));&#10;          } else {&#10;            const path = url.pathname || '';&#10;            if (path &amp;&amp; path !== '/') {&#10;              const parts = path.split('/').filter(Boolean);&#10;              const last = parts[parts.length - 1];&#10;              if (last) {&#10;                target = [...blogPosts, ...cmsArticlesList].find(x =&gt; String(x.slug) === String(last) || String(x.id) === String(last));&#10;              }&#10;            }&#10;          }&#10;&#10;          if (target) {&#10;            // 内部プレビュー&#10;            const imgSrc = target.image?.url || target.image || '/sample-images/no-image.jpg';&#10;            const wrapper = document.createElement('div');&#10;            wrapper.className = 'link-preview';&#10;&#10;            const img = document.createElement('img');&#10;            img.src = imgSrc;&#10;            img.alt = target.title || '';&#10;            img.onerror = function() { this.src = '/sample-images/no-image.jpg'; };&#10;&#10;            const titleDiv = document.createElement('div');&#10;            titleDiv.className = 'lp-title';&#10;            titleDiv.textContent = target.title || String(target.id || target.slug || href);&#10;&#10;            wrapper.appendChild(img);&#10;            wrapper.appendChild(titleDiv);&#10;&#10;            a.innerHTML = '';&#10;            a.appendChild(wrapper);&#10;            a.classList.add('link-preview');&#10;            a.dataset.previewApplied = '1';&#10;          } else {&#10;            // 外部リンク&#10;            const isHttp = /^https?:/.test(url.protocol);&#10;            const isSameOrigin = url.origin === window.location.origin;&#10;            if (isHttp &amp;&amp; !isSameOrigin) {&#10;              const domain = url.hostname.replace(/^www\./, '');&#10;&#10;              const wrapper = document.createElement('div');&#10;              wrapper.className = 'ext-inner';&#10;&#10;              // ファビコンは表示しない（省略）。meta のみ作成。&#10;              const meta = document.createElement('div');&#10;              meta.className = 'ext-meta';&#10;&#10;              const titleDiv = document.createElement('div');&#10;              titleDiv.className = 'ext-title';&#10;              titleDiv.textContent = a.textContent ? a.textContent.trim() : href;&#10;&#10;              const domainDiv = document.createElement('div');&#10;              domainDiv.className = 'ext-domain';&#10;              domainDiv.textContent = domain;&#10;&#10;              meta.appendChild(titleDiv);&#10;              meta.appendChild(domainDiv);&#10;&#10;              wrapper.appendChild(meta);&#10;&#10;              // 追加: 外部感を示す小さな矢印アイコンを追加&#10;              const arrow = document.createElement('span');&#10;              arrow.className = 'ext-arrow';&#10;              arrow.innerHTML = `&#10;                &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; aria-hidden=&quot;true&quot;&gt;&#10;                  &lt;path d=&quot;M5 12h14&quot;&gt;&lt;/path&gt;&#10;                  &lt;path d=&quot;M12 5l7 7-7 7&quot;&gt;&lt;/path&gt;&#10;                &lt;/svg&gt;`;&#10;              wrapper.appendChild(arrow);&#10;&#10;              a.innerHTML = '';&#10;              a.appendChild(wrapper);&#10;              a.classList.add('external-link');&#10;              a.setAttribute('target', '_blank');&#10;              a.setAttribute('rel', 'noopener noreferrer');&#10;              a.dataset.previewApplied = '1';&#10;&#10;              // eslint-disable-next-line no-console&#10;              console.log('[ArticlePage] converted external link:', href, '-&gt;', domain);&#10;            }&#10;          }&#10;        } catch (e) {&#10;          // eslint-disable-next-line no-console&#10;          console.warn('[ArticlePage] anchor processing failed for', a, e);&#10;        }&#10;      });&#10;    };&#10;&#10;    // 初回実行&#10;    processAnchors();&#10;    window.mergeSeparatedExtInner &amp;&amp; window.mergeSeparatedExtInner();&#10;    window.hideTextOnlyExternalAnchors &amp;&amp; window.hideTextOnlyExternalAnchors();&#10;&#10;&#10;    // --- converted: global utility functions for merging/hiding external links ---&#10;    window.mergeSeparatedExtInner = function() {&#10;      try {&#10;        const containerEl = articleContentRef?.current || document.body;&#10;        if (!containerEl) return;&#10;        const inners = Array.from(containerEl.querySelectorAll('.ext-inner'));&#10;        inners.forEach(inner =&gt; {&#10;          // skip if already inside an anchor&#10;          if (inner.closest('a.external-link')) return;&#10;          // find nearest anchor siblings that share the same href&#10;  // hrefCandidates / aSiblings removed (unused)&#10;          // collect anchors that have same href and are adjacent to this inner&#10;          let anchor = null;&#10;          // look back&#10;          let prev = inner.previousElementSibling;&#10;          while(prev) { if (prev.tagName === 'A' &amp;&amp; prev.classList.contains('external-link')) { anchor = prev; break; } prev = prev.previousElementSibling; }&#10;          // look forward if not found&#10;          if (!anchor) { let next = inner.nextElementSibling; while(next) { if (next.tagName === 'A' &amp;&amp; next.classList.contains('external-link')) { anchor = next; break; } next = next.nextElementSibling; } }&#10;          // if anchor still not found, try to find any anchor that has same href as inner's internal anchors&#10;          if (!anchor) { const innerA = inner.querySelector('a.external-link'); const href = innerA ? innerA.getAttribute('href') : null; if (href) { anchor = Array.from(containerEl.querySelectorAll('a.external-link')).find(x=&gt;x.getAttribute('href')===href); } }&#10;          // if still not found, create one and insert before inner&#10;          if (!anchor) { anchor = document.createElement('a'); anchor.className = 'external-link'; const innerA = inner.querySelector('a.external-link'); if (innerA &amp;&amp; innerA.getAttribute('href')) anchor.setAttribute('href', innerA.getAttribute('href')); anchor.setAttribute('target','_blank'); anchor.setAttribute('rel','noopener noreferrer'); anchor.dataset.previewApplied = '1'; inner.parentNode.insertBefore(anchor, inner); }&#10;          // move arrow if exists in adjacent anchor&#10;          const possibleArrowAnchor = inner.nextElementSibling &amp;&amp; inner.nextElementSibling.tagName==='A' &amp;&amp; inner.nextElementSibling.classList.contains('external-link') &amp;&amp; inner.nextElementSibling.querySelector('.ext-arrow') ? inner.nextElementSibling : null;&#10;          if (possibleArrowAnchor) {&#10;            const arrow = possibleArrowAnchor.querySelector('.ext-arrow');&#10;            if (arrow) anchor.appendChild(arrow);&#10;            try { possibleArrowAnchor.parentNode.removeChild(possibleArrowAnchor); } catch (e) {}&#10;          }&#10;          // replace any anchors inside inner with spans to avoid nested anchors&#10;          const innerAnchors = Array.from(inner.querySelectorAll('a.external-link'));&#10;          innerAnchors.forEach(aEl =&gt; { try { const span = document.createElement('span'); span.className = 'ext-link-text'; span.textContent = aEl.textContent || aEl.getAttribute('href') || ''; aEl.parentNode.replaceChild(span, aEl); } catch(e){} });&#10;          // finally append inner into anchor&#10;          try { anchor.appendChild(inner); } catch(e){}&#10;        });&#10;      } catch(e) {}&#10;        };&#10;        window.hideTextOnlyExternalAnchors = function() {&#10;      try {&#10;        const containerEl = articleContentRef?.current || document.body;&#10;        if (!containerEl) return;&#10;        const anchors = Array.from(containerEl.querySelectorAll('a.external-link'));&#10;        anchors.forEach(a =&gt; {&#10;          try {&#10;            // skip anchors that have structured content or arrow inside&#10;            if (a.querySelector('.ext-inner') || a.querySelector('.ext-arrow')) return;&#10;            const href = (a.getAttribute('href') || '').trim();&#10;            const txt = (a.textContent || '').trim();&#10;            if (!href) return;&#10;            if (!txt) { a.style.display = 'none'; return; }&#10;            // if text exactly equals href (or equals href without protocol), hide it&#10;            const noProto = href.replace(/^https?:\/\//, '');&#10;            if (txt === href || txt === noProto) {&#10;              a.style.display = 'none';&#10;            }&#10;          } catch (e) {}&#10;        });&#10;      } catch (e) {}&#10;        };&#10;    &#10;&#10;&#10;    // --- 追加: クライアント側で分離している .ext-inner と隣接する a.external-link を統合する ---&#10;    &#10;&#10;    // --- 追加: テキストだけの a.external-link（URLそのものを表示しているもの）を非表示にする ---&#10;    &#10;&#10;&#10;&#10;&#10;&#10;    // --- 追加: クライアント側で分離している .ext-inner と隣接する a.external-link を統合する ---&#10;    &#10;&#10;    // --- 追加: テキストのみの a.external-link を非表示にする（URLだけのもの） ---&#10;    &#10;&#10;&#10;&#10;&#10;    // MutationObserver で遅延挿入されるリンクに対応する&#10;    let observer = null;&#10;    try {&#10;      observer = new MutationObserver(mutations =&gt; {&#10;        let shouldProcess = false;&#10;        for (const m of mutations) {&#10;          if (m.type === 'childList' &amp;&amp; m.addedNodes &amp;&amp; m.addedNodes.length) {&#10;            shouldProcess = true;&#10;            break;&#10;          }&#10;        }&#10;        if (shouldProcess) {&#10;          // 小さな遅延で再処理&#10;          setTimeout(()=&gt;{ processAnchors(); window.mergeSeparatedExtInner &amp;&amp; window.mergeSeparatedExtInner(); window.hideTextOnlyExternalAnchors &amp;&amp; window.hideTextOnlyExternalAnchors(); }, 50);&#10;        }&#10;      });&#10;      observer.observe(container, { childList: true, subtree: true });&#10;    } catch (e) {&#10;      // 観測に失敗しても問題ない&#10;    }&#10;&#10;    return () =&gt; {&#10;      if (observer) observer.disconnect();&#10;    };&#10;  }, [contentWithIds, cmsArticlesList]);&#10;&#10;  // AdSense広告の初期化&#10;  useEffect(() =&gt; {&#10;    if (window.adsbygoogle &amp;&amp; adRef.current) {&#10;      try {&#10;        window.adsbygoogle.push({});&#10;      } catch (e) {}&#10;    }&#10;  }, [id]);&#10;  // microCMS記事でも関連記事を表示（ローカル+CMS両方から抽出）&#10;  const allArticles = [&#10;    ...blogPosts,&#10;    ...cmsArticlesList&#10;  ];&#10;  // 正規化したカテゴリ名を返すユーティリティ&#10;  function getCategoryName(a) {&#10;    if (!a) return undefined;&#10;    if (a.category &amp;&amp; typeof a.category === 'object') return a.category.name;&#10;    return a.category;&#10;  }&#10;  // 現在の投稿の正規カテゴリ名&#10;  const currentCatName = getCategoryName(post);&#10;  // slug/id を文字列化&#10;  const postSlug = post?.slug ? String(post.slug) : String(post?.id || '');&#10;  const related = allArticles.filter(p =&gt; {&#10;    const pSlug = p.slug ? String(p.slug) : String(p.id || '');&#10;    // カテゴリ名が同じ、かつ自身以外&#10;    return getCategoryName(p) === currentCatName &amp;&amp; pSlug !== postSlug;&#10;  });&#10;&#10;  // ローカル記事もなく、まだ CMS からの取得が終わっていない場合は何も表示しない（フラッシュ防止）&#10;  const hasLocal = blogPosts.find(p =&gt; p.slug === id || p.id === id);&#10;  if (!post) {&#10;    if (!hasLocal &amp;&amp; cmsArticle === undefined) {&#10;      // loading: 表示を出さずフラッシュを防止&#10;      return null;&#10;    }&#10;    // 取得済みだが存在しない場合はメッセージ表示&#10;    return &lt;ArticleContainer&gt;記事が見つかりませんでした。&lt;/ArticleContainer&gt;;&#10;  }&#10;&#10;&#10;  return (&#10;    &lt;&gt;&#10;  {/* EyeCatch削除: 記事ごとの画像のみ表示 */}&#10;      &lt;ArticleContainer&gt;&#10;        &lt;ArticleTitle&gt;{post.title}&lt;/ArticleTitle&gt;&#10;        &lt;div style={{display:'flex', justifyContent:'center', position: 'relative'}}&gt;&#10;          {/* 日付を画像の上、右寄せでオーバーレイ表示 */}&#10;          {publishedDate &amp;&amp; (&#10;            &lt;ArticleDate&gt;&#10;              {publishedDate} に公開&#10;            &lt;/ArticleDate&gt;&#10;          )}&#10;          &lt;ArticleImageEyeCatch src={imageUrl} alt={post.title} className={isVertical ? 'vertical' : ''} /&gt;&#10;        &lt;/div&gt;&#10;        {/* 目次 */}&#10;        {toc.length &gt; 0 &amp;&amp; (&#10;          &lt;TocContainer aria-label=&quot;目次&quot;&gt;&#10;            &lt;strong style={{color:'#1B5E20'}}&gt;目次&lt;/strong&gt;&#10;            &lt;TocList&gt;&#10;              {toc.map(item =&gt; (&#10;                &lt;TocItem key={item.id} className={`toc-${item.tag}`}&gt;&#10;                  &lt;TocLink href={`#${item.id}`}&gt;{item.text}&lt;/TocLink&gt;&#10;                &lt;/TocItem&gt;&#10;              ))}&#10;            &lt;/TocList&gt;&#10;          &lt;/TocContainer&gt;&#10;        )}&#10;        &lt;ArticleContent ref={articleContentRef} dangerouslySetInnerHTML={{ __html: contentWithIds }} /&gt;&#10;        {/* Google AdSense in-article広告ユニット */}&#10;        &lt;div style={{margin: '32px 0', display: 'flex', justifyContent: 'center'}}&gt;&#10;          &lt;ins className=&quot;adsbygoogle&quot;&#10;            style={{ display: 'block', textAlign: 'center' }}&#10;            data-ad-layout=&quot;in-article&quot;&#10;            data-ad-format=&quot;fluid&quot;&#10;            data-ad-client=&quot;ca-pub-7728107798566122&quot;&#10;            data-ad-slot=&quot;5951785085&quot;&#10;            ref={adRef}&#10;          &gt;&lt;/ins&gt;&#10;        &lt;/div&gt;&#10;        {related.length &gt; 0 &amp;&amp; (&#10;          &lt;RelatedSection&gt;&#10;            &lt;RelatedTitle&gt;&lt;FaLink /&gt; 関連ページ&lt;/RelatedTitle&gt;&#10;            &lt;RelatedList&gt;&#10;              {related.map(r =&gt; {&#10;                const relImg = r.image?.url || r.image;&#10;                const relLink = `/?p=${r.slug || r.id}`;&#10;                return (&#10;                  &lt;RelatedCard to={relLink} key={r.slug || r.id}&gt;&#10;                    &lt;RelatedImage src={relImg} alt={r.title} /&gt;&#10;                    &lt;RelatedCardTitle&gt;{r.title}&lt;/RelatedCardTitle&gt;&#10;                  &lt;/RelatedCard&gt;&#10;                );&#10;              })}&#10;             &lt;/RelatedList&gt;&#10;           &lt;/RelatedSection&gt;&#10;         )}&#10;        &lt;BackLink to=&quot;/&quot;&gt;&#10;          &lt;FaArrowLeft /&gt; トップページへ戻る&#10;        &lt;/BackLink&gt;&#10;      &lt;/ArticleContainer&gt;&#10;    &lt;/&gt;&#10;  );&#10;};&#10;&#10;export default ArticlePage;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>